0=> Poralekha (PoraLekha/poralekha/pora-lekha) is an educative application...
FullStack;
Frontend->Flutter(Mobiles(Android+iOS), Desktops(Linux+MacOS+Windows), WebApp, Embedded) and Next(React(Web));
Backend->Laravel(Api(Breeze-next)).

https://flutter.dev/
Multi-Platform

Mobile
Web
Desktop
Embedded

pwd
ls
ls -a
git init
touch README.md
git add .
git branch -M origin main
git -h
git --help
git remote -v
git remote add origin https://github.com/ProSolver-org/poralekha
git push origin main
git branch
git status
git commit -m "0=>InitialCommit"
git branch -m main
git branch -m main
git push origin -u main
git push -u origin main

poralekha
This is an educative application. This is built with laraval api backend and next (react(web)) - flutter (mobile(iOS+Android)+desktops(MacOS+Windows+Linux+WebApp)) frontends...

git remote set-url origin https://github.com/ProSolver-org/poralekha
git remote set-url origin https://github.com/ProSolver-org/poralekha.git
nano .git/config
git config --list
git push -f origin main
git pull --rebase
git pull https://github.com/ProSolver-org/poralekha.git main
git push -u origin main
git help submodule
https://git-scm.com/book/en/v2/Git-Tools-Submodules
https://github.com/ProSolver-org/breeze-next-laravel
git push origin HEAD:main
git status

‚Ä¶or create a new repository on the command line
echo "# next-backend" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/ProSolver-org/next-backend.git
git push -u origin main

‚Ä¶or push an existing repository from the command line
git remote add origin https://github.com/ProSolver-org/next-backend.git
git branch -M main
git push -u origin main

‚Ä¶or import code from another repository
You can initialize this repository with code from a Subversion, Mercurial, or TFS project.

# 0=>

.gitignore (Laravel)

/vendor/
node_modules/
npm-debug.log
yarn-error.log

# Laravel 4 specific

bootstrap/compiled.php
app/storage/

# Laravel 5 & Lumen specific

public/storage
public/hot

# Laravel 5 & Lumen specific with changed public path

public_html/storage
public_html/hot

storage/\*.key
.env
Homestead.yaml
Homestead.json
/.vagrant
.phpunit.result.cache

# 0=>

.gitignore (Node)

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log\*

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
\*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
\*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# TypeScript v1 declaration files

typings/

# TypeScript cache

\*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

\*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variables file

.env
.env.test

# parcel-bundler cache (https://parceljs.org/)

.cache

# Next.js build output

.next

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

.cache/

# Comment in the public line in if your project uses Gatsby and _not_ Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port
0=>
.gitignore(Dart)

# See https://www.dartlang.org/guides/libraries/private-files

# Files and directories created by pub

.dart_tool/
.packages
build/

# If you're building an application, you may want to check-in your pubspec.lock

pubspec.lock

# Directory created by dartdoc

# If you don't generate documentation locally you can remove this line.

doc/api/

# Avoid committing generated Javascript files:

_.dart.js
_.info.json # Produced by the --dump-info flag.
_.js # When generated by dart2js. Don't specify _.js if your # project includes source files written in JavaScript.
_.js\_
_.js.deps
\*.js.map
0=>
.gitignore(Composer)
composer.phar
/vendor/

# Commit your application's lock file https://getcomposer.org/doc/01-basic-usage.md#commit-your-composer-lock-file-to-version-control

# You may choose to ignore a library lock file http://getcomposer.org/doc/02-libraries.md#lock-file

# composer.lock

0=>
https://bloclibrary.dev/#/fluttercountertutorial

Project Structure
‚îú‚îÄ‚îÄ lib
‚îÇ ‚îú‚îÄ‚îÄ app.dart
‚îÇ ‚îú‚îÄ‚îÄ counter
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ counter.dart
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cubit
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ counter_cubit.dart
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ view
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ counter_page.dart
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ counter_view.dart
‚îÇ ‚îú‚îÄ‚îÄ counter_observer.dart
‚îÇ ‚îî‚îÄ‚îÄ main.dart
‚îú‚îÄ‚îÄ pubspec.lock
‚îú‚îÄ‚îÄ pubspec.yaml
Copy to clipboardErrorCopied
The application uses a feature-driven directory structure. This project structure enables us to scale the project by having self-contained features. In this example we will only have a single feature (the counter itself) but in more complex applications we can have hundreds of different features.

https://github.com/ProSolver-org/bloc/tree/master/examples/flutter_counter/lib/counter/cubit

git submodule add next-ba
ckend --recursive
repo URL: 'next-backend' must be absolute or begin with ./|../
roneemrayhan@Ronees-MacBook-Air ÓÇ∞ ~/RayhanWorld/RoneeMRayhan/poralekha ÓÇ∞ ÓÇ† main ‚úö ÓÇ∞ git submodule add ./next-backend next-backend --recursive
'next-backend' already exists in the index

0=>
https://codewithandrea.com/articles/flutter-project-structure/
For reference, here's how my final project structure ended up:

‚Ä£ lib
‚Ä£ >src
‚Ä£ >>common_widgets
‚Ä£ >>constants
‚Ä£ >>exceptions
‚Ä£ >>features
‚Ä£ >>>address
‚Ä£ >>>authentication
‚Ä£ >>>cart
‚Ä£ >>>checkout
‚Ä£ >>>orders
‚Ä£ >>>products
‚Ä£ >>>reviews
‚Ä£ >>localization
‚Ä£ >>routing
‚Ä£ >>utils

Without even looking inside folders such as common_widgets, constants, exceptions, localization, routing, and utils, we can guess that they all contain code that is truly shared across features, or needs to be centralized for a good reason (such as localization and routing).

And these folders all contain relatively little code.

Bonus: the test folder
I haven't talked about this until now. But it makes a lot of sense for the test folder to follow the same project structure as the lib folder.

And this is very easy to do by using the "Go to Tests" option in VSCode:
image.png

cart

> application
> data
> domain
> presentation
>
> > add_to_cart
> > cart_total
> > shopping_cart
> >
> > > shopping_cart_item_controller.dart
> > > shopping_cart_item.dart
> > > shopping_cart_items_builder.dart
> > > shopping_cart_screen.dart

checkout
orders
products

VSCode option to Go to Tests from any file in the "lib" folder
For any given file inside lib, this will create a \_test.dart file in the corresponding location inside test. üëç

Conclusion
When done right, going feature-first has many benefits over layer-first.

Php artisan make:middleware cors

https://www.positronx.io/how-to-use-fetch-api-to-get-data-in-react-with-rest-api/

https://statusneo.com/different-ways-to-fetch-data-from-api-in-reactjs/
https://bloclibrary.dev/#/flutterlogintutorial
https://github.com/felangel/Bloc/tree/master/examples/flutter_login
https://bloclibrary.dev/#/fluttercountertutorial
https://github.com/felangel/Bloc/tree/master/examples/flutter_counter
